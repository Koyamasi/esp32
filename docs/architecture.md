# Architecture

This firmware is built around a lightweight event bus that lets input drivers
publish what they detect while other tasks consume those events.

## Event types and queue

Events are defined in [`Event.h`](../main/Event.h) and carried through the
[`EventQueue`](../main/EventQueue.h).

* **`ButtonEdge`** – generated by `Button` and `FourButtons` when a debounced
  GPIO input changes state.  The `id` field identifies which button moved and
  `data.down` is `true` when the button is pressed.
* **`PotBucket`** – generated by `Potentiometer` when the ADC reading crosses
  into a new bucket.  `data.bucket` holds the bucket number (`1`–`8`).

Producers call `EventQueue::send()` to post an `Event`.  Consumers, such as the
serial task, call `recv()` to wait for the next event.  The queue itself is a
thin wrapper around a FreeRTOS queue for type safety.

## Polling loop and `SerialMessenger`

[`app_main.cpp`](../main/app_main.cpp) sets up the hardware components and the
central `EventQueue`, then launches `SerialMessenger` in its own task.  The
`app_main` function enters a polling loop:

1. `btn.poll()` checks the primary button.
2. `four.poll()` polls a block of four additional buttons.
3. `pot.poll()` runs at a throttled rate to reduce noise.
4. `vTaskDelay()` sleeps for the configured interval.

Each poller posts events to the queue as necessary.  `SerialMessenger` waits on
that queue and prints a line of text for each event:

* `BTN,<id>,DOWN` or `BTN,<id>,UP` for button edges.
* `POT,<id>,<bucket>` for potentiometer buckets.

## Example serial output

Pressing and releasing button `1` while the potentiometer moves to bucket `4`
produces output similar to:

```
BTN,1,DOWN
BTN,1,UP
POT,1,4
```
